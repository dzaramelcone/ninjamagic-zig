<!doctype html>
<html>
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">  <meta charset="utf-8" />
  <title>MUD – Single-Terminal UI</title>
  <!-- xterm core UMD build -->
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.css" />
  <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js"></script>

  <!-- WebGL renderer addon UMD build -->
  <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-webgl@0.18.0/lib/addon-webgl.js"></script>

  <style>
    html,body{margin:0;height:100%;background:#111}
    #term{width:100%;height:100%; cursor:default;}
    .xterm-cursor-layer { opacity: 0 !important; }
    #caret {
      position: absolute;
      width: 2px;                           /* thin bar */
      background: #9ff;
      pointer-events: none;
      transition: transform 80ms ease;      /* smooth glide */
    }  
</style>
</head>
<body>
  <div id="term"></div>
<script>
/* ====== 0. params ====== */
const COLS = 80, ROWS = 18;
const MAP_W = 40,  MAP_H = 12;
const CHAT_TOP = 31, CHAT_BOT = 38;
const lakeMask = [];
const seedX = Math.random() * 1000;
const seedY = Math.random() * 1000;

function noise(x, y) {
  /* 2-D value noise via sine mixing – lightweight, deterministic */
  return (
    Math.sin((x * 0.15) + seedX) +
    Math.sin((y * 0.12) + seedY) +
    Math.sin(((x + y) * 0.08) + seedX * 0.3)
  ) / 3;
}
for (let y = 0; y < MAP_H; y++) {
  lakeMask[y] = [];
  for (let x = 0; x < MAP_W; x++) {
    lakeMask[y][x] = noise(x, y) > 0.15;   // threshold → water/land
  }
}
/* ====== 1. boot terminal ====== */
const term = new Terminal({
  cols: COLS,
  rows: ROWS,
  allowProposedApi: true,
  fontFamily: "'OpenSans', monospace",
  fontSize: 32,           // tweak for taste (pixels)
  lineHeight: 1.15,       // a little breathing room
  letterSpacing: 10,        // keep monospace metrics exact
  cursorStyle: 'bar' 
 });
term.loadAddon(new WebglAddon.WebglAddon());
term.open(document.getElementById('term'));
term.resize(COLS, ROWS);

/* helpers */
const CSI   = (...a) => `\x1b[${a.join(';')}`;
const goto  = (r, c) => CSI(r, c) + 'H';
const save  = '\x1b7', restore = '\x1b8';

/* configure chat scroll band */
term.write(CSI(`${CHAT_TOP};${CHAT_BOT}r`));

/* ====== 2. sidebar with health bars ====== */
const enemies = [
  { name: 'Rat',      hp: 35, max: 50,  color: [200, 60, 60]  },
  { name: 'Bandit',   hp: 72, max: 100, color: [220,120, 40]  },
  { name: 'Gargoyle', hp: 18, max: 80,  color: [160, 40,160]  }
];
function barLine(e){
  const len = 20, filled = Math.round(len*e.hp/e.max);
  const [r,g,b] = e.color;
  return [
    e.name.padEnd(10).slice(0,10),' ',
    CSI(`48;2;${r};${g};${b}m`),'█'.repeat(filled),
    CSI('48;2;30;30;30m'),' '.repeat(len-filled),
    CSI('0m'),` ${e.hp}/${e.max}`
  ].join('');
}
function renderSidebar(){
  term.write(save + goto(1, MAP_W+1));
  enemies.forEach((e,i)=>term.write(barLine(e).padEnd(30).slice(0,30) + goto(i+2, MAP_W+1)));
  term.write(restore);
}
renderSidebar();

/* ====== 3. colorful lake animation ====== */
let phase = 0;
function hsl(h,s,l){         /* returns [r,g,b] 0-255 */
  s/=100; l/=100;
  const k=n=>(n+h/30)%12, a=s*Math.min(l,1-l);
  const f=n=>l-a*Math.max(-1,Math.min(k(n)-3,Math.min(9-k(n),1)));
  return [f(0),f(8),f(4)].map(v=>Math.round(v*255));
}
/* --- drawLake: irregular shape + random twinkle ------------------ */
const baseHue = 210;             // blue
const palette = Array.from({ length: 8 }, (_, i) =>
  hsl(baseHue, 50, 26 + i * 4)    // 8 blue shades
);

function drawLake() {
  const buf = [];
  for (let y = 0; y < MAP_H; y++) {
    for (let x = 0; x < MAP_W; x++) {
      if (lakeMask[y][x]) {
        /* random sparkle: 2 % chance to nudge shade this frame */
        const jitter = Math.random() < 0.02 ? (Math.random()<0.5?-1:1) : 0;
        const idx = (x + y + phase + jitter) & 7;   // 0–7 palette index
        const [r, g, b] = palette[idx];
        buf.push(CSI(`38;2;180;230;255;48;2;${r};${g};${b}m~`));
      } else {
        buf.push(CSI('0m.'));                       // land
      }
    }
    buf.push('\r\n');
  }
  term.write(save + goto(1, 1) + buf.join('') + CSI('0m') + restore);
}
/* ====== 4. chat utilities ====== */
function chat(msg){
  term.write(save + goto(CHAT_BOT,1) + msg + '\r\n' + restore);
}
/* -------- prompt & input (final fix) -------- */
let line = '';

function drawPrompt() {
  term.write(goto(ROWS, 1) + CSI('32m') + '> ' + CSI('0m') + CSI('K'));
  line = '';
}
drawPrompt();

term.onData(data => {
  const ch   = data;
  const code = ch.charCodeAt(0);

  if (code === 13) {                     // Enter
    if (line.length) {
      chat(`\x1b[32m> ${line}\x1b[0m`);
      /* TODO send to server here */
    }
    drawPrompt();
  }
  else if (code === 127) {               // Backspace
    if (line.length) {
      line = line.slice(0, -1);
      term.write('\b \b');               // visual erase
    }
  }
  else if (code >= 32 && code <= 126) {  // printable ASCII
    line += ch;
    term.write(ch);                      // ← echo the character
  }
});
const caret = document.createElement('div');
caret.id = 'caret';
document.getElementById('term').appendChild(caret);

/* helper to convert col,row → pixel position */
function cursorPx(term) {
  const dims = term._core._renderService.dimensions;     // private but stable
  const {actualCellWidth: cw, actualCellHeight: ch} = dims;
  const row = term.buffer.active.cursorY;
  const col = term.buffer.active.cursorX;
  return { x: col * cw, y: row * ch, h: ch };
}

/* first paint */
const { x, y, h } = cursorPx(term);
caret.style.height = h + 'px';
caret.style.transform = `translate(${x}px, ${y}px)`;

/* move caret whenever the cursor moves */
term.onCursorMove(() => {
  const { x, y, h } = cursorPx(term);
  caret.style.height = h + 'px';                // handle font resize
  caret.style.transform = `translate(${x}px, ${y}px)`;
});

/* if you resize the terminal, recalc once */
window.addEventListener('resize', () => {
  const { x, y, h } = cursorPx(term);
  caret.style.height = h + 'px';
  caret.style.transform = `translate(${x}px, ${y}px)`;
});
/* =====  main animation loop stays the same  ===== */
function tick(){
  phase = (phase + 0.05) % 360;
  enemies.forEach(e => { if (e.hp > 0 && Math.random() < 0.01) e.hp--; });
  drawLake();
  renderSidebar();
  requestAnimationFrame(tick);
}
tick();
</script>
</body>
</html>
