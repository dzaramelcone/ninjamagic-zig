<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MUD Prototype – Split UI</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono,wght@300;400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/xterm.css" />
  <script src="/xterm.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-webgl@0.18.0/lib/addon-webgl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>

  <style>
  :root{
    /* Material-3 dark palette */
    --bg        : #396e78;   /* near-black, cool */
    --surface   : #405e64;   /* cards/panels */
    --on-surface: #ECE6F0;   /* primary text */
    --primary   : #7DD3FC;   /* accent blue */
    --danger    : #F38BA8;   /* HP bar red */
  --bg        : #1B1E26;
  --surface   : #1C1F27;
  --on-surface: #ECE6F0;
  --primary   : #7DD3FC;
  --danger    : #F38BA8;

  /* 16-colour ANSI map (names match xterm theme keys) */
    --ansi-black         : var(--bg);
    --ansi-red           : var(--danger);
    --ansi-green         : #8BD5A1;
    --ansi-yellow        : #F9E2AF;
    --ansi-blue          : var(--primary);
    --ansi-magenta       : #D0A8FF;
    --ansi-cyan          : #94E2D5;
    --ansi-white         : var(--on-surface);

    --ansi-bright-black  : #2A2E37;
    --ansi-bright-red    : #F6A0B8;
    --ansi-bright-green  : #A6E3B0;
    --ansi-bright-yellow : #FAF0BF;
    --ansi-bright-blue   : #A5E4FF;
    --ansi-bright-magenta: #E1C2FF;
    --ansi-bright-cyan   : #B0F1E4;
    --ansi-bright-white  : #FFFFFF;
    /* layout constants */
    --chat-h    : 28%;
    --prompt-h  : 38px;
    --row-h:22px
  }

  html,body{
    margin:0;height:100%;
    background:var(--bg);
    color:var(--on-surface);
    font-family:'IBM Plex Mono', monospace;
    display:flex;flex-direction:column;justify-content:center;align-items:center;
  }
  #card{
    display:flex;                   /* stack map + prompt */
    flex-direction:column;
    align-items:center;
    gap:8px;                        /* space between map and prompt */

    padding:20px 24px;              /* breathing room inside card */
    border-radius:18px;             /* soft corners */
    background:var(--surface);      /* slightly lighter than page bg */

    /* subtle depth */
    /* box-shadow:
        0 1px 2px rgba(0,0,0,0.4),
        0 4px 16px rgba(0,0,0,0.25); */

    /* thin inner stroke for definition */
    /* outline:1px solid rgba(255,255,255,0.05); */
  }
  /* keep #mapBox shadow but clip to card radius */
  #mapBox{border-radius:12px;overflow:hidden}

  #chat, #prompt input{
    font:19px 'IBM Plex Mono', monospace;
    letter-spacing:0;                 /* identical tracking          */
  }
  #chat, .msg, #cmd{
    font-weight:300;                 /* lighter look             */
    color:var(--primary);         /* theme text colour         */
  }
  #chat{
    width:100%;
    max-width:calc(80ch + 8px);
    height:calc(var(--row-h) * 8); /* 8 visible rows, no clip */
    display:flex; flex-direction:column;
    justify-content:flex-end;      /* newest at the bottom    */
    overflow:hidden;
  }

  .msg{
    height:var(--row-h);
    line-height:var(--row-h);      /* centres glyphs vertically */
    font:19px 'IBM Plex Mono', monospace;
    white-space:pre;
    transition:opacity .4s;
  }
  /* prompt bar --------------------------------------------------- */
  #prompt{
    width:100%;
    max-width:calc(40ch + 8px);
    padding-top:8px;                     /* sits flush under chat log   */
    display:flex;align-items:center;
    border-top:1px solid rgba(255,255,255,.07);
  }
  #cmd{
    flex:1;border:none;outline:none;
    padding:0;                        /* first char aligns perfectly */
    background:transparent;color:var(--on-surface);
    caret-color:var(--primary);
  }

</style>
</head>
<body>
<div id="card">
  <div id="mapBox"></div>
  <div id="chat"></div>
  <div id="prompt"><input id="cmd" autocomplete="off"></div>
</div>
<script>
/*--------------------------------------------------
  1.  Constants & world generation  (40 × 12 grid)
--------------------------------------------------*/
/* tiny colour helpers */
const pack   =(r,g,b)=>(r<<16)|(g<<8)|b;
const unpack =rgb=>[(rgb>>16)&255,(rgb>>8)&255,rgb&255];
function hsl(H,S,L){
  S/=100; L/=100;
  const k=n=>(n+H/30)%12, a=S*Math.min(L,1-L);
  const f=n=>L-a*Math.max(-1,Math.min(k(n)-3,Math.min(9-k(n),1)));
  return [f(0),f(8),f(4)].map(v=>Math.round(v*255));
}
const hexToRgb = hex => hex.match(/\w\w/g).map(h=>parseInt(h,16));
function rgbToHsv(r, g, b) {          // r-g-b 0-255 → h 0-1, s/v 0-1
  r /= 255; g /= 255; b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  const d   = max - min;
  const v   = max;
  const s   = max === 0 ? 0 : d / max;
  let h     = 0;

  if (d !== 0) {
    switch (max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2;               break;
      case b: h = (r - g) / d + 4;               break;
    }
    h /= 6;
  }
  return [h, s, v];
}
function hsvToRgb(h, s, v) {          // h 0-1, s/v 0-1 → r-g-b 0-255
  const i = Math.floor(h * 6);
  const f = h * 6 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  let r, g, b;
  switch (i % 6) {
    case 0: r = v; g = t; b = p; break;
    case 1: r = q; g = v; b = p; break;
    case 2: r = p; g = v; b = t; break;
    case 3: r = p; g = q; b = v; break;
    case 4: r = t; g = p; b = v; break;
    case 5: r = v; g = p; b = q; break;
  }
  return [r * 255 | 0, g * 255 | 0, b * 255 | 0];
}
function lerpHSV(aRgb, bRgb, t) {
  const [ar, ag, ab] = unpack(aRgb);
  const [br, bg, bb] = unpack(bRgb);
  let   [h1, s1, v1] = rgbToHsv(ar, ag, ab);
  let   [h2, s2, v2] = rgbToHsv(br, bg, bb);

  /* wrap hue through shortest arc */
  let dh = h2 - h1;
  if (dh >  0.5) dh -= 1;
  if (dh < -0.5) dh += 1;
  const h = (h1 + dh * t + 1) % 1;
  const s = s1 + (s2 - s1) * t;
  const v = v1 + (v2 - v1) * t;

  const [r, g, b] = hsvToRgb(h, s, v);
  return pack(r, g, b);
}

const css = getComputedStyle(document.documentElement);
const cssVar = name => css.getPropertyValue(name).trim();
const ansi = n => cssVar(`--ansi-${n}`);
const FG_WATER = hexToRgb(cssVar('--ansi-blue'));          // water uses theme blue
const FG_LAND  = hexToRgb(cssVar('--ansi-bright-black'));  // land = bright black
const BG_PAGE  = pack(...hexToRgb(cssVar('--surface')));            // background surface
const theme = {
  background : cssVar('--surface'),
  foreground : cssVar('--on-surface'),
  cursor     : cssVar('--primary'),

  black         : ansi('black'),
  red           : ansi('red'),
  green         : ansi('green'),
  yellow        : ansi('yellow'),
  blue          : ansi('blue'),
  magenta       : ansi('magenta'),
  cyan          : ansi('cyan'),
  white         : ansi('white'),
  brightBlack   : ansi('bright-black'),
  brightRed     : ansi('bright-red'),
  brightGreen   : ansi('bright-green'),
  brightYellow  : ansi('bright-yellow'),
  brightBlue    : ansi('bright-blue'),
  brightMagenta : ansi('bright-magenta'),
  brightCyan    : ansi('bright-cyan'),
  brightWhite   : ansi('bright-white')
};
const COLS = 13, ROWS = 13;
/* world array & lake mask */



/*--------------------------------------------------
  2. Layer buffers
--------------------------------------------------*/
const baseGlyph    = new Uint16Array(COLS * ROWS);
const baseFG       = new Uint32Array(COLS * ROWS);
const world        = Array.from({ length: ROWS }, () => Array(COLS).fill('.'));
const lakeMask     = Array.from({ length: ROWS }, () => Array(COLS).fill(false));

const vignette      = new Float32Array(COLS * ROWS);
const radiusFactor  = .9;   // 1 = edge-to-edge, 0.75 = wider bright core
const falloffPower  = 1.4;    // <2 keeps mid-tones brighter, >2 darkens
const cx = (COLS - 1) / 2, cy = (ROWS - 1) / 2;
const maxR = Math.hypot(cx, cy) * radiusFactor;   // shrink “max” radius
for (let y = 0; y < ROWS; y++) {
  for (let x = 0; x < COLS; x++) {
    const d = Math.hypot(x - cx, y - cy) / maxR;  // 0 → centre, >1 outside
    const t = Math.min(1, d);                     // clamp
    const k = (1 - t) ** falloffPower;            // 1 → 0 brightness
    vignette[y * COLS + x] = k;
  }
}

for (let y = 0; y < ROWS; y++) {
  for (let x = 0; x < COLS; x++) {
    const n = (Math.sin(x * 0.15) + Math.sin(y * 0.12) + Math.sin((x + y) * 0.08)) / 3;
    lakeMask[y][x] = n > 0.15;
    if (lakeMask[y][x]) world[y][x] = '~';
  }
}
/* seed base layer */
(function initBase(){
  for (let y=0;y<ROWS;y++){
    for (let x=0;x<COLS;x++){
      const i = y*COLS + x;
      const water = lakeMask[y][x];

      baseGlyph[i] = water ? '~'.codePointAt(0) : '.'.codePointAt(0);
      baseFG[i]    = water ? pack(...FG_WATER)  : pack(...FG_LAND);
    }
  }
})();

/*--------------------------------------------------
  5. Per-cell composition
--------------------------------------------------*/
function composeCell(idx) {
  let fg = baseFG[idx];
  let g  = baseGlyph[idx];
  const k = vignette[idx];
  fg = lerpHSV(fg, BG_PAGE, 1 - k);
  return { g, fg };
}

/*--------------------------------------------------
  6. Frame renderer
--------------------------------------------------*/
function composeFrame(term) {
  let out = '';
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      const idx = y * COLS + x;
      const { g, fg } = composeCell(idx);         // ignore bg
      const [r, g2, b] = unpack(fg);
      out += `\x1b[38;2;${r};${g2};${b}m${String.fromCodePoint(g)}`;
    }
    if (y < ROWS - 1) out += '\r\n';
  }
  term.write('\x1b[H' + out + '\x1b[0m');        // reset at end
}
/*--------------------------------------------------
  7. Boot xterm
--------------------------------------------------*/


const term = new Terminal({
  rows: ROWS,
  cols: COLS,
  allowProposedApi:true,
  fontFamily:"'Open Sans', monospace",
  fontSize:32,
  letterSpacing:20,
  theme
});

const webgl = new WebglAddon.WebglAddon();
term.loadAddon(webgl);
term.open(document.getElementById('mapBox'));

/*--------------------------------------------------
  8. Main loop
--------------------------------------------------*/
function tick(){
  composeFrame(term);
  requestAnimationFrame(tick);
}
tick();
/*--------------------------------------------------
chat initialisation (alignment & fade)
--------------------------------------------------*/
const chat = document.getElementById('chat');
const cmd  = document.getElementById('cmd');
cmd.focus();

/* seed with 8 blank lines so the box is always full */
for (let i = 0; i < 8; i++){
  const div = document.createElement('div');
  div.className = 'msg'; div.innerHTML = '&nbsp;';
  chat.appendChild(div);
}
function postLine(text){
  const div = document.createElement('div');
  div.className = 'msg';
  div.textContent = text;
  chat.appendChild(div);

  /* keep only the newest 8 */
  while (chat.children.length > 8) chat.removeChild(chat.firstChild);

  /* exponential fade: 1.00, 0.55, 0.30 … bottom → top */
  [...chat.children].reverse().forEach((el, i) => {
    el.style.opacity = Math.max(0.07, Math.pow(0.55, i));
  });
}
postLine('*** Welcome to the prototype! ***');

cmd.addEventListener('keydown', e=>{
  if (e.key === 'Enter' && cmd.value.trim()){
    postLine(cmd.value);
    cmd.value = '';
  }
});
</script>
</body>
</html>
